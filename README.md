# Процедурная справедливость для распределения курсов (черновик + этап улучшений)

Этот README объясняет, как добавить **процедурную справедливость** (справедливое «право голоса» в принятии решений) в проект по **распределению курсов**, который уже использует:
- начальное распределение через **драфт / «змейку»** (в стиле HBS), и
- **фазу улучшений** с $N$ итерациями (локальный поиск / обмены).

Цель — обсудить эту идею с преподавателями **простым и понятным** языком.

---

## 1) Мотивация

Большинство систем распределения курсов измеряют справедливость только по **результату**:
- кто получил топ‑курсы,
- суммарная полезность,
- неравенство (например, Gini),
- зависть (envy).

Но современные работы по **процедурной справедливости** говорят:
> Справедливость — это ещё и про **процесс**: был ли у каждого студента честный шанс повлиять на решения?

Иначе говоря:
- Справедливость по результату = *что ты получил*
- Процедурная справедливость = *насколько твои предпочтения реально учитывались в ходе принятия решений*

Это особенно важно, когда мы запускаем:
- жадный драфт,
- а затем повторяющиеся улучшения, которые могут снова и снова приносить выгоду одним и тем же студентам.

---

## 2) Ключевая идея: «голос» / доля решений

### 2.1 Что такое Decision Share?

Для каждого студента $i$ задаём множество его **любимых вариантов** (например, Top‑1 или Top‑$k$ курсов, которые всё ещё достижимы/возможны).

**Decision Share** измеряет, как часто алгоритм даёт студенту что‑то из этого любимого множества.

Есть два практических определения (выбери одно — в зависимости от того, что у тебя доступно в реализации):

#### A) По результату (самый простой вариант, если есть только финальные расписания)
Каждый студент получает $K_i$ курсов.

Пусть `TopK(i)` = топ‑$k$ курсов студента.

$$
DS_i = \frac{\#\{c \in \text{Assigned}(i) \cap \text{TopK}(i)\}}{\min(K_i, k)}
$$

Интерпретация:
- $DS_i = 1$: студент получил только курсы из топ‑$k$ (сильный «голос»)
- $DS_i = 0$: студент не получил ни одного курса из топ‑$k$ (слабый «голос»)

#### B) По процессу (лучший вариант, если у тебя есть раунды драфта / логи шагов)
На каждом шаге $t$ студент $i$ имеет любимое множество среди **текущих доступных** курсов.

$$
DS_i = \frac{1}{T_i}\sum_{t \in \text{steps of }i} \mathbf{1}\{\text{choice}_t(i) \in \text{Favorites}_t(i)\}
$$

Интерпретация:
- измеряет, насколько *процесс* стабильно уважает топ‑выборы студента.

---

## 3) Почему это «новое» для распределения курсов

Традиционные метрики могут выглядеть хорошо, даже если процедурная справедливость плохая.

Пример:
- суммарная полезность растёт,
- но система снова и снова «слушает» одну и ту же группу (студентов с более высоким приоритетом или с удачным порядком драфта),
- а другие студенты редко получают свои лучшие достижимые варианты.

Процедурная справедливость даёт дополнительную оптику:
- **Не оптимизируем ли мы благосостояние (welfare) ценой репрезентативности/«права голоса» студентов?**

---

## 4) Метрики, которые можно добавить в проект

### 4.1 Метрики результата (стандартные)
- **Суммарная полезность**:
  $$
  U_{\text{total}} = \sum_i U_i
  $$
- **Top‑X rate**: % студентов, которые получили хотя бы один Top‑1 / Top‑3 курс
- **Gini по полезностям**:
  - считать по $\{U_i\}$

### 4.2 Процедурные метрики (новый слой)
- **Decision Share по каждому студенту**: $\{DS_i\}$
- **Gini(DS)**: неравенство «голоса»
- **Min DS**: $\min_i DS_i$ (защита наихудшего случая)
- **DS Nash Welfare (DSNW)** (балансирует «голос» между студентами):
  $$
  DSNW = \prod_i (DS_i + \epsilon)
  $$
  где $\epsilon$ — маленькая константа, чтобы не умножать на ноль (используется **только** для вычисления метрики).

> DSNW будет высоким только если у **большинства** студентов есть нетривиальный «голос».

### 4.3 Стабильность (опционально, но академически сильно)
- **Swap‑regret**: сколько взаимовыгодных обменов ещё существует после оптимизации?
- **Envy rate**: % студентов, которые завидуют расписанию кого‑то другого

---

## 5) Как интегрировать процедурную справедливость в алгоритм

У тебя уже есть:
1) **Фаза A**: драфт‑распределение («змейка»)
2) **Фаза B**: улучшение (N итераций)

Процедурную справедливость проще всего добавлять именно в Фазу B.

---

## 6) Предлагаемые варианты алгоритма

### Вариант 0 (база)
- Только Фаза A (драфт), без улучшений.

### Вариант 1 (улучшение только по welfare)
- Фаза A + Фаза B (локальный поиск)
- Принимаем ход, если он увеличивает суммарную полезность:
  $$
  \Delta U_{\text{total}} > 0
  $$

### Вариант 2 (учитываем процедурную справедливость) ✅ (основное предложение)
- Фаза A + Фаза B (локальный поиск)
- Принимаем ход только если он улучшает welfare **и при этом не ухудшает «голос»**, например:

**Правило A (жёсткое ограничение):**
$$
\Delta U_{\text{total}} > 0 \quad \text{и} \quad \min_i DS_i \ge \tau
$$
Смысл:
- улучшаем welfare,
- но гарантируем каждому студенту хотя бы $\tau$ «голоса» (например, $\tau = 0.2$ для Top‑3).

**Правило B (мультикритериальная цель):**
$$
\text{принять, если } \Delta \big(U_{\text{total}} + \lambda \cdot \log(DSNW)\big) > 0
$$
Смысл:
- настраиваем $\lambda$, чтобы регулировать компромисс между welfare и процедурной справедливостью.

**Правило C (tie‑break):**
Если два хода дают похожий прирост welfare, выбираем тот, у которого выше DSNW.

---

## 7) Какие «ходы» может использовать Фаза B?

Можно оставить текущую логику улучшений и просто добавить правила принятия.
Типичные ходы:

1) **Переназначение одного курса** (если позволяет вместимость)
2) **2‑swap**: обмен одним курсом между двумя студентами
3) **k‑цикл**: обмены A→B→C→A (опционально)

Главная новая часть — не тип хода, а **критерий принятия с учётом процедурной справедливости**.

---

## 8) Какие данные собирать у студентов

Минимально:
- ранжирование курсов (позиции 1..M)
- опционально: score/интенсивность по каждому курсу (1..5)

Для процедурной справедливости:
- нужно определить Top‑$k$ для DS (например, $k=3$)

Опционально (для более сильной дипломной работы):
- список «избегать» (1–2 человека или курса)
- список «друзья» (топ‑3 людей)
- персональные веса:
  - кому‑то важнее друзья,
  - кому‑то важнее курсы.

---

## 9) Модель полезности (простая)

### 9.1 Полезность курса
Пусть $pos(i,c)$ — ранг (1 = лучший).
Простая убывающая функция:

$$
U_{\text{course}}(i,c) = M - pos(i,c) + 1
$$

Если есть score $score(i,c)$, можно объединять:

$$
U_{\text{course}}(i,c) = a \cdot score(i,c) + b \cdot (M - pos(i,c) + 1)
$$

### 9.2 Социальная полезность (опционально)
Если студент $i$ хочет студента $j$ в том же курсе:

$$
U_{\text{social}}(i) = \sum_{c \in \text{Assigned}(i)} \sum_{j \in \text{AssignedToCourse}(c)} w_{ij}
$$

Итого:

$$
U_i = \sum_{c \in \text{Assigned}(i)} U_{\text{course}}(i,c) + \gamma \cdot U_{\text{social}}(i)
$$

---

## 10) Маленький пример (игрушечный)

- 4 студента: A, B, C, D  
- 3 курса: X, Y, Z  
- Вместимость: 2 на курс  
- Каждый студент получает $K=1$

Пусть Top‑2 для каждого студента:
- A: X, Y
- B: X, Y
- C: X, Z
- D: Y, Z

Результат S1:
- A→X, B→X, C→Z, D→Y

Decision Share (Top‑2):
- A получил X (Top‑2) → DS=1
- B получил X (Top‑2) → DS=1
- C получил Z (Top‑2) → DS=1
- D получил Y (Top‑2) → DS=1

Результат S2 (хуже по процедурной справедливости):
- A→X, B→Y, C→Y, D→Z
Если у C Top‑2 = {X, Z}, тогда C получил Y → DS=0

Здесь суммарная полезность может быть похожей, но процедурная справедливость отличается:
- S1: min DS = 1
- S2: min DS = 0

---

## 11) Схема системы

```mermaid
flowchart TD
  A[Вход: предпочтения по курсам<br/>ранг/score + вместимости + K] --> B[Фаза A: драфт «змейкой»]
  B --> C[Начальное расписание S0]
  C --> D[Фаза B: улучшение (N итераций)]
  D --> E{Правило принятия хода}
  E -->|Только welfare| F[Принять, если ΔU_total > 0]
  E -->|С учётом процедурной справедливости| G[Принять, если улучшает welfare<br/>И сохраняет справедливость DS]
  F --> H[Финальное расписание S*]
  G --> H[Финальное расписание S*]
  H --> I[Отчёт: Utility, Gini(U), DS, Gini(DS), DSNW, Stability]
```
